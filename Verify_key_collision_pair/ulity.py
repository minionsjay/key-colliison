from typing import List
from functools import reduce
from random import seed
from random import randint

sbox = [
    0x63,
    0x7C,
    0x77,
    0x7B,
    0xF2,
    0x6B,
    0x6F,
    0xC5,
    0x30,
    0x01,
    0x67,
    0x2B,
    0xFE,
    0xD7,
    0xAB,
    0x76,
    0xCA,
    0x82,
    0xC9,
    0x7D,
    0xFA,
    0x59,
    0x47,
    0xF0,
    0xAD,
    0xD4,
    0xA2,
    0xAF,
    0x9C,
    0xA4,
    0x72,
    0xC0,
    0xB7,
    0xFD,
    0x93,
    0x26,
    0x36,
    0x3F,
    0xF7,
    0xCC,
    0x34,
    0xA5,
    0xE5,
    0xF1,
    0x71,
    0xD8,
    0x31,
    0x15,
    0x04,
    0xC7,
    0x23,
    0xC3,
    0x18,
    0x96,
    0x05,
    0x9A,
    0x07,
    0x12,
    0x80,
    0xE2,
    0xEB,
    0x27,
    0xB2,
    0x75,
    0x09,
    0x83,
    0x2C,
    0x1A,
    0x1B,
    0x6E,
    0x5A,
    0xA0,
    0x52,
    0x3B,
    0xD6,
    0xB3,
    0x29,
    0xE3,
    0x2F,
    0x84,
    0x53,
    0xD1,
    0x00,
    0xED,
    0x20,
    0xFC,
    0xB1,
    0x5B,
    0x6A,
    0xCB,
    0xBE,
    0x39,
    0x4A,
    0x4C,
    0x58,
    0xCF,
    0xD0,
    0xEF,
    0xAA,
    0xFB,
    0x43,
    0x4D,
    0x33,
    0x85,
    0x45,
    0xF9,
    0x02,
    0x7F,
    0x50,
    0x3C,
    0x9F,
    0xA8,
    0x51,
    0xA3,
    0x40,
    0x8F,
    0x92,
    0x9D,
    0x38,
    0xF5,
    0xBC,
    0xB6,
    0xDA,
    0x21,
    0x10,
    0xFF,
    0xF3,
    0xD2,
    0xCD,
    0x0C,
    0x13,
    0xEC,
    0x5F,
    0x97,
    0x44,
    0x17,
    0xC4,
    0xA7,
    0x7E,
    0x3D,
    0x64,
    0x5D,
    0x19,
    0x73,
    0x60,
    0x81,
    0x4F,
    0xDC,
    0x22,
    0x2A,
    0x90,
    0x88,
    0x46,
    0xEE,
    0xB8,
    0x14,
    0xDE,
    0x5E,
    0x0B,
    0xDB,
    0xE0,
    0x32,
    0x3A,
    0x0A,
    0x49,
    0x06,
    0x24,
    0x5C,
    0xC2,
    0xD3,
    0xAC,
    0x62,
    0x91,
    0x95,
    0xE4,
    0x79,
    0xE7,
    0xC8,
    0x37,
    0x6D,
    0x8D,
    0xD5,
    0x4E,
    0xA9,
    0x6C,
    0x56,
    0xF4,
    0xEA,
    0x65,
    0x7A,
    0xAE,
    0x08,
    0xBA,
    0x78,
    0x25,
    0x2E,
    0x1C,
    0xA6,
    0xB4,
    0xC6,
    0xE8,
    0xDD,
    0x74,
    0x1F,
    0x4B,
    0xBD,
    0x8B,
    0x8A,
    0x70,
    0x3E,
    0xB5,
    0x66,
    0x48,
    0x03,
    0xF6,
    0x0E,
    0x61,
    0x35,
    0x57,
    0xB9,
    0x86,
    0xC1,
    0x1D,
    0x9E,
    0xE1,
    0xF8,
    0x98,
    0x11,
    0x69,
    0xD9,
    0x8E,
    0x94,
    0x9B,
    0x1E,
    0x87,
    0xE9,
    0xCE,
    0x55,
    0x28,
    0xDF,
    0x8C,
    0xA1,
    0x89,
    0x0D,
    0xBF,
    0xE6,
    0x42,
    0x68,
    0x41,
    0x99,
    0x2D,
    0x0F,
    0xB0,
    0x54,
    0xBB,
    0x16,
]
mul_two = [
    0x00,
    0x02,
    0x04,
    0x06,
    0x08,
    0x0A,
    0x0C,
    0x0E,
    0x10,
    0x12,
    0x14,
    0x16,
    0x18,
    0x1A,
    0x1C,
    0x1E,
    0x20,
    0x22,
    0x24,
    0x26,
    0x28,
    0x2A,
    0x2C,
    0x2E,
    0x30,
    0x32,
    0x34,
    0x36,
    0x38,
    0x3A,
    0x3C,
    0x3E,
    0x40,
    0x42,
    0x44,
    0x46,
    0x48,
    0x4A,
    0x4C,
    0x4E,
    0x50,
    0x52,
    0x54,
    0x56,
    0x58,
    0x5A,
    0x5C,
    0x5E,
    0x60,
    0x62,
    0x64,
    0x66,
    0x68,
    0x6A,
    0x6C,
    0x6E,
    0x70,
    0x72,
    0x74,
    0x76,
    0x78,
    0x7A,
    0x7C,
    0x7E,
    0x80,
    0x82,
    0x84,
    0x86,
    0x88,
    0x8A,
    0x8C,
    0x8E,
    0x90,
    0x92,
    0x94,
    0x96,
    0x98,
    0x9A,
    0x9C,
    0x9E,
    0xA0,
    0xA2,
    0xA4,
    0xA6,
    0xA8,
    0xAA,
    0xAC,
    0xAE,
    0xB0,
    0xB2,
    0xB4,
    0xB6,
    0xB8,
    0xBA,
    0xBC,
    0xBE,
    0xC0,
    0xC2,
    0xC4,
    0xC6,
    0xC8,
    0xCA,
    0xCC,
    0xCE,
    0xD0,
    0xD2,
    0xD4,
    0xD6,
    0xD8,
    0xDA,
    0xDC,
    0xDE,
    0xE0,
    0xE2,
    0xE4,
    0xE6,
    0xE8,
    0xEA,
    0xEC,
    0xEE,
    0xF0,
    0xF2,
    0xF4,
    0xF6,
    0xF8,
    0xFA,
    0xFC,
    0xFE,
    0x1B,
    0x19,
    0x1F,
    0x1D,
    0x13,
    0x11,
    0x17,
    0x15,
    0x0B,
    0x09,
    0x0F,
    0x0D,
    0x03,
    0x01,
    0x07,
    0x05,
    0x3B,
    0x39,
    0x3F,
    0x3D,
    0x33,
    0x31,
    0x37,
    0x35,
    0x2B,
    0x29,
    0x2F,
    0x2D,
    0x23,
    0x21,
    0x27,
    0x25,
    0x5B,
    0x59,
    0x5F,
    0x5D,
    0x53,
    0x51,
    0x57,
    0x55,
    0x4B,
    0x49,
    0x4F,
    0x4D,
    0x43,
    0x41,
    0x47,
    0x45,
    0x7B,
    0x79,
    0x7F,
    0x7D,
    0x73,
    0x71,
    0x77,
    0x75,
    0x6B,
    0x69,
    0x6F,
    0x6D,
    0x63,
    0x61,
    0x67,
    0x65,
    0x9B,
    0x99,
    0x9F,
    0x9D,
    0x93,
    0x91,
    0x97,
    0x95,
    0x8B,
    0x89,
    0x8F,
    0x8D,
    0x83,
    0x81,
    0x87,
    0x85,
    0xBB,
    0xB9,
    0xBF,
    0xBD,
    0xB3,
    0xB1,
    0xB7,
    0xB5,
    0xAB,
    0xA9,
    0xAF,
    0xAD,
    0xA3,
    0xA1,
    0xA7,
    0xA5,
    0xDB,
    0xD9,
    0xDF,
    0xDD,
    0xD3,
    0xD1,
    0xD7,
    0xD5,
    0xCB,
    0xC9,
    0xCF,
    0xCD,
    0xC3,
    0xC1,
    0xC7,
    0xC5,
    0xFB,
    0xF9,
    0xFF,
    0xFD,
    0xF3,
    0xF1,
    0xF7,
    0xF5,
    0xEB,
    0xE9,
    0xEF,
    0xED,
    0xE3,
    0xE1,
    0xE7,
    0xE5,
]

invmul_nine = [
    0x00,
    0x4F,
    0x9E,
    0xD1,
    0x27,
    0x68,
    0xB9,
    0xF6,
    0x4E,
    0x01,
    0xD0,
    0x9F,
    0x69,
    0x26,
    0xF7,
    0xB8,
    0x9C,
    0xD3,
    0x02,
    0x4D,
    0xBB,
    0xF4,
    0x25,
    0x6A,
    0xD2,
    0x9D,
    0x4C,
    0x03,
    0xF5,
    0xBA,
    0x6B,
    0x24,
    0x23,
    0x6C,
    0xBD,
    0xF2,
    0x04,
    0x4B,
    0x9A,
    0xD5,
    0x6D,
    0x22,
    0xF3,
    0xBC,
    0x4A,
    0x05,
    0xD4,
    0x9B,
    0xBF,
    0xF0,
    0x21,
    0x6E,
    0x98,
    0xD7,
    0x06,
    0x49,
    0xF1,
    0xBE,
    0x6F,
    0x20,
    0xD6,
    0x99,
    0x48,
    0x07,
    0x46,
    0x09,
    0xD8,
    0x97,
    0x61,
    0x2E,
    0xFF,
    0xB0,
    0x08,
    0x47,
    0x96,
    0xD9,
    0x2F,
    0x60,
    0xB1,
    0xFE,
    0xDA,
    0x95,
    0x44,
    0x0B,
    0xFD,
    0xB2,
    0x63,
    0x2C,
    0x94,
    0xDB,
    0x0A,
    0x45,
    0xB3,
    0xFC,
    0x2D,
    0x62,
    0x65,
    0x2A,
    0xFB,
    0xB4,
    0x42,
    0x0D,
    0xDC,
    0x93,
    0x2B,
    0x64,
    0xB5,
    0xFA,
    0x0C,
    0x43,
    0x92,
    0xDD,
    0xF9,
    0xB6,
    0x67,
    0x28,
    0xDE,
    0x91,
    0x40,
    0x0F,
    0xB7,
    0xF8,
    0x29,
    0x66,
    0x90,
    0xDF,
    0x0E,
    0x41,
    0x8C,
    0xC3,
    0x12,
    0x5D,
    0xAB,
    0xE4,
    0x35,
    0x7A,
    0xC2,
    0x8D,
    0x5C,
    0x13,
    0xE5,
    0xAA,
    0x7B,
    0x34,
    0x10,
    0x5F,
    0x8E,
    0xC1,
    0x37,
    0x78,
    0xA9,
    0xE6,
    0x5E,
    0x11,
    0xC0,
    0x8F,
    0x79,
    0x36,
    0xE7,
    0xA8,
    0xAF,
    0xE0,
    0x31,
    0x7E,
    0x88,
    0xC7,
    0x16,
    0x59,
    0xE1,
    0xAE,
    0x7F,
    0x30,
    0xC6,
    0x89,
    0x58,
    0x17,
    0x33,
    0x7C,
    0xAD,
    0xE2,
    0x14,
    0x5B,
    0x8A,
    0xC5,
    0x7D,
    0x32,
    0xE3,
    0xAC,
    0x5A,
    0x15,
    0xC4,
    0x8B,
    0xCA,
    0x85,
    0x54,
    0x1B,
    0xED,
    0xA2,
    0x73,
    0x3C,
    0x84,
    0xCB,
    0x1A,
    0x55,
    0xA3,
    0xEC,
    0x3D,
    0x72,
    0x56,
    0x19,
    0xC8,
    0x87,
    0x71,
    0x3E,
    0xEF,
    0xA0,
    0x18,
    0x57,
    0x86,
    0xC9,
    0x3F,
    0x70,
    0xA1,
    0xEE,
    0xE9,
    0xA6,
    0x77,
    0x38,
    0xCE,
    0x81,
    0x50,
    0x1F,
    0xA7,
    0xE8,
    0x39,
    0x76,
    0x80,
    0xCF,
    0x1E,
    0x51,
    0x75,
    0x3A,
    0xEB,
    0xA4,
    0x52,
    0x1D,
    0xCC,
    0x83,
    0x3B,
    0x74,
    0xA5,
    0xEA,
    0x1C,
    0x53,
    0x82,
    0xCD,
]
inv_sbox = [
    0x52,
    0x09,
    0x6A,
    0xD5,
    0x30,
    0x36,
    0xA5,
    0x38,
    0xBF,
    0x40,
    0xA3,
    0x9E,
    0x81,
    0xF3,
    0xD7,
    0xFB,
    0x7C,
    0xE3,
    0x39,
    0x82,
    0x9B,
    0x2F,
    0xFF,
    0x87,
    0x34,
    0x8E,
    0x43,
    0x44,
    0xC4,
    0xDE,
    0xE9,
    0xCB,
    0x54,
    0x7B,
    0x94,
    0x32,
    0xA6,
    0xC2,
    0x23,
    0x3D,
    0xEE,
    0x4C,
    0x95,
    0x0B,
    0x42,
    0xFA,
    0xC3,
    0x4E,
    0x08,
    0x2E,
    0xA1,
    0x66,
    0x28,
    0xD9,
    0x24,
    0xB2,
    0x76,
    0x5B,
    0xA2,
    0x49,
    0x6D,
    0x8B,
    0xD1,
    0x25,
    0x72,
    0xF8,
    0xF6,
    0x64,
    0x86,
    0x68,
    0x98,
    0x16,
    0xD4,
    0xA4,
    0x5C,
    0xCC,
    0x5D,
    0x65,
    0xB6,
    0x92,
    0x6C,
    0x70,
    0x48,
    0x50,
    0xFD,
    0xED,
    0xB9,
    0xDA,
    0x5E,
    0x15,
    0x46,
    0x57,
    0xA7,
    0x8D,
    0x9D,
    0x84,
    0x90,
    0xD8,
    0xAB,
    0x00,
    0x8C,
    0xBC,
    0xD3,
    0x0A,
    0xF7,
    0xE4,
    0x58,
    0x05,
    0xB8,
    0xB3,
    0x45,
    0x06,
    0xD0,
    0x2C,
    0x1E,
    0x8F,
    0xCA,
    0x3F,
    0x0F,
    0x02,
    0xC1,
    0xAF,
    0xBD,
    0x03,
    0x01,
    0x13,
    0x8A,
    0x6B,
    0x3A,
    0x91,
    0x11,
    0x41,
    0x4F,
    0x67,
    0xDC,
    0xEA,
    0x97,
    0xF2,
    0xCF,
    0xCE,
    0xF0,
    0xB4,
    0xE6,
    0x73,
    0x96,
    0xAC,
    0x74,
    0x22,
    0xE7,
    0xAD,
    0x35,
    0x85,
    0xE2,
    0xF9,
    0x37,
    0xE8,
    0x1C,
    0x75,
    0xDF,
    0x6E,
    0x47,
    0xF1,
    0x1A,
    0x71,
    0x1D,
    0x29,
    0xC5,
    0x89,
    0x6F,
    0xB7,
    0x62,
    0x0E,
    0xAA,
    0x18,
    0xBE,
    0x1B,
    0xFC,
    0x56,
    0x3E,
    0x4B,
    0xC6,
    0xD2,
    0x79,
    0x20,
    0x9A,
    0xDB,
    0xC0,
    0xFE,
    0x78,
    0xCD,
    0x5A,
    0xF4,
    0x1F,
    0xDD,
    0xA8,
    0x33,
    0x88,
    0x07,
    0xC7,
    0x31,
    0xB1,
    0x12,
    0x10,
    0x59,
    0x27,
    0x80,
    0xEC,
    0x5F,
    0x60,
    0x51,
    0x7F,
    0xA9,
    0x19,
    0xB5,
    0x4A,
    0x0D,
    0x2D,
    0xE5,
    0x7A,
    0x9F,
    0x93,
    0xC9,
    0x9C,
    0xEF,
    0xA0,
    0xE0,
    0x3B,
    0x4D,
    0xAE,
    0x2A,
    0xF5,
    0xB0,
    0xC8,
    0xEB,
    0xBB,
    0x3C,
    0x83,
    0x53,
    0x99,
    0x61,
    0x17,
    0x2B,
    0x04,
    0x7E,
    0xBA,
    0x77,
    0xD6,
    0x26,
    0xE1,
    0x69,
    0x14,
    0x63,
    0x55,
    0x21,
    0x0C,
    0x7D,
]


def xor_bytes(*arg: bytes) -> bytes:
    assert len({len(x) for x in arg}) == 1  # all args must have the same length
    xor_fun = lambda x, y: x ^ y
    return bytes(reduce(xor_fun, byt3s) for byt3s in zip(*arg))


def rot_word(word: bytes) -> bytes:
    """
    apply the RotWord transformation to a bytes object of length 4
    """
    assert len(word) == 4
    return bytes((word[(i + 1) % 4] for i in range(4)))


def inv_rot_word(word: bytes) -> bytes:
    """
    apply the inverse of the RotWord transformation to a bytes object of length 4
    """
    assert len(word) == 4
    return bytes((word[(i - 1) % 4] for i in range(4)))


def sub_word(word: bytes) -> bytes:
    """
    apply the AES S-Box to each of the bytes of the 4-byte word
    """
    assert len(word) == 4
    return bytes((sbox[w] for w in word))


def sub_state(word: bytes) -> bytes:
    """
    apply the AES S-Box to each of the bytes of the 4-byte word
    """
    assert len(word) == 16
    return bytes((sbox[w] for w in word))


def mix_col(word: bytes) -> bytes:
    assert len(word) == 4
    return (
        xor_bytes(twom_word(word[0:1]), threem_word(word[1:2]), word[2:3], word[3:4])
        + xor_bytes(twom_word(word[1:2]), threem_word(word[2:3]), word[0:1], word[3:4])
        + xor_bytes(twom_word(word[2:3]), threem_word(word[3:4]), word[0:1], word[1:2])
        + xor_bytes(twom_word(word[3:4]), threem_word(word[0:1]), word[2:3], word[1:2])
    )


def inv_mix_col(word: bytes) -> bytes:
    assert len(word) == 4
    return (
        xor_bytes(
            em_word(word[0:1]),
            bm_word(word[1:2]),
            dm_word(word[2:3]),
            ninem_word(word[3:4]),
        )
        + xor_bytes(
            em_word(word[1:2]),
            bm_word(word[2:3]),
            ninem_word(word[0:1]),
            dm_word(word[3:4]),
        )
        + xor_bytes(
            em_word(word[2:3]),
            bm_word(word[3:4]),
            dm_word(word[0:1]),
            ninem_word(word[1:2]),
        )
        + xor_bytes(
            em_word(word[3:4]),
            bm_word(word[0:1]),
            ninem_word(word[2:3]),
            dm_word(word[1:2]),
        )
    )


def sub_byte(word: bytes) -> bytes:
    assert len(word) == 1
    return bytes([sbox[word[0]]])


def inv_sub_word(word: bytes) -> bytes:
    """
    apply the inverse of the AES S-Box to each of the bytes of the 4-byte word
    """
    assert len(word) == 4
    return bytes((inv_sbox[w] for w in word))


def inv_sub_state(word: bytes) -> bytes:
    """
    apply the inverse of the AES S-Box to each of the bytes of the 4-byte word
    """
    assert len(word) == 16
    return bytes((inv_sbox[w] for w in word))


def inv_sub_byte(word: bytes) -> bytes:
    assert len(word) == 1
    return bytes([inv_sbox[word[0]]])


def twom_word(word: bytes) -> bytes:
    assert len(word) == 1
    return bytes([mul_two[word[0]]])


def inv_mul_twom(word: bytes) -> bytes:
    assert len(word) == 1
    for i in range(256):
        if twom_word(bytes([i])) == word:
            return bytes([i])


def inv_mul_ninem(word: bytes) -> bytes:
    assert len(word) == 1
    return bytes([invmul_nine[word[0]]])


def threem_int(word: int) -> bytes:
    """
    multiply word with 3
    """
    assert word <= 255
    return xor_bytes(bytes([word]), mul_two[word].to_bytes(1, "little"))


def threem_word(word: bytes) -> bytes:
    assert len(word) == 1
    return threem_int(word[0])


def inv_mul_threem(word: bytes) -> bytes:
    assert len(word) == 1
    for i in range(256):
        if threem_int(i) == word:
            return bytes([i])


def ninem_int(word: int) -> bytes:
    """
    multiply word with 3
    """
    assert word <= 255
    return xor_bytes(
        bytes([word]), mul_two[mul_two[mul_two[word]]].to_bytes(1, "little")
    )


def ninem_word(word: bytes) -> bytes:
    assert len(word) == 1
    return ninem_int(word[0])


def bm_int(word: int) -> bytes:
    """
    multiply word with 3
    """
    assert word <= 255
    return xor_bytes(
        threem_int(word), mul_two[mul_two[mul_two[word]]].to_bytes(1, "little")
    )


def bm_word(word: bytes) -> bytes:
    assert len(word) == 1
    return bm_int(word[0])


def inv_mul_bm(word: bytes) -> bytes:
    assert len(word) == 1
    for i in range(256):
        if bm_int(i) == word:
            return bytes([i])


def dm_word(word: bytes) -> bytes:
    """
    multiply word with d
    """
    assert len(word) == 1
    return xor_bytes(ninem_word(word), mul_two[mul_two[word[0]]].to_bytes(1, "little"))


def em_word(word: bytes) -> bytes:
    """
    multiply word with e
    """
    assert len(word) == 1
    return xor_bytes(
        threem_int(mul_two[word[0]]),
        mul_two[mul_two[mul_two[word[0]]]].to_bytes(1, "little"),
    )


def key_schedule(base_key: bytes) -> List[bytes]:
    """
    calculate the expanded AES key given the base key.
    Depending on the length of the base key 11, 13 or 15 round keys are returned
    for AES-128, AES-192 and AES-256 respectively.
    """
    assert len(base_key) * 8 in {128, 192, 256}

    # length of the key in 32 bit words
    N = {128: 4, 192: 6, 256: 8}[len(base_key) * 8]

    # number of round keys needed
    R = {128: 11, 192: 13, 256: 15}[len(base_key) * 8]

    # the 32 bits words of the expanded key
    W = [None for _ in range(R * 4)]

    for i in range(N):
        W[i] = base_key[i * 4 : (i + 1) * 4]

    for i in range(N, 4 * R):
        if i % N == 0:
            W[i] = xor_bytes(W[i - N], sub_word(rot_word(W[i - 1])), rcon[i // N - 1])
        elif N > 6 and i % N == 4:
            W[i] = xor_bytes(W[i - N], sub_word(W[i - 1]))
        else:
            W[i] = xor_bytes(W[i - N], W[i - 1])

    keys = [b"".join(W[i * 4 + j] for j in range(4)) for i in range(R)]
    return keys


def inverse_MC(word: bytes) -> bytes:
    assert len(word) == 4
    return (
        xor_bytes(
            em_word(word[0:1]),
            bm_word(word[1:2]),
            dm_word(word[2:3]),
            ninem_word(word[3:4]),
        )
        + xor_bytes(
            ninem_word(word[0:1]),
            em_word(word[1:2]),
            bm_word(word[2:3]),
            dm_word(word[3:4]),
        )
        + xor_bytes(
            dm_word(word[0:1]),
            ninem_word(word[1:2]),
            em_word(word[2:3]),
            bm_word(word[3:4]),
        )
        + xor_bytes(
            bm_word(word[0:1]),
            dm_word(word[1:2]),
            ninem_word(word[2:3]),
            em_word(word[3:4]),
        )
    )


def find_pair(indiff: int, outdiff: int):

    s = set()
    for i in range(0, 256):
        ## x'
        j = xor_bytes(bytes([i]), indiff.to_bytes(1, "little"))
        # print(f"x:{i},x':{int.from_bytes(j,'little')}")
        k = j[0]
        if xor_bytes(
            sbox[i].to_bytes(1, "little"), sbox[k].to_bytes(1, "little")
        ) == outdiff.to_bytes(1, "little"):
            s.add(i)
            s.add(k)
    return list(s)


def find_random_pair(indiff: bytes, outdiff: bytes) -> bytes:
    for i in range(0, 256):
        j = xor_bytes(bytes([i]), outdiff)[0]
        if xor_bytes(bytes([inv_sbox[i]]), bytes([inv_sbox[j]])) == indiff:
            return bytes([i])
    return 0


def find_random_input(indiff: bytes, outdiff: bytes) -> bytes:
    for i in range(0, 256):
        j = xor_bytes(bytes([i]), indiff)[0]
        if xor_bytes(bytes([sbox[i]]), bytes([sbox[j]])) == outdiff:
            return bytes([i])
    return 0


# print(find_pair(1,2))
# print(1.to_bytes(1,'little'))
# pairs=[]
# ddt_pairs={}
# for i in range(1,256):
#     for j in range(1,256):
#         pair=find_pair(i,j)
#         if pair!=[]:
#             ddt_pairs[(i,j)]=pair
#         pairs.append(find_pair(i,j))
def extract_hex(word: bytes):
    l = len(word)
    r = ""
    for i in range(l):
        r += hex(word[i])
        r += ", "

    return r


def state_str_to_int(state):
    # Remove any spaces or other unnecessary characters
    cleaned_string = state.replace(" ", "").strip()

    # Convert the string into bytes, two characters at a time
    byte_array = [cleaned_string[i : i + 2] for i in range(0, len(cleaned_string), 2)]
    # Convert the byte strings into integers
    byte_array = [int(byte, 16) for byte in byte_array]

    # Split into groups of 4 bytes each
    result = [byte_array[i : i + 4] for i in range(0, len(byte_array), 4)]

    return result


rcon = [
    x.to_bytes(4, "little")
    for x in [
        0x01,
        0x02,
        0x04,
        0x08,
        0x10,
        0x20,
        0x40,
        0x80,
        0x1B,
        0x36,
    ]
]


def shift_rows(state):
    index = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11]
    # print(state[0])
    new_state = []
    for i in range(16):
        new_state += [state[index[i]]]
    return bytes(new_state)
